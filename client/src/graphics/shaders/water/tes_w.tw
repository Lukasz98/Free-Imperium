#version 450 core

layout(triangles, equal_spacing, cw) in;

in TCS_OUT
{
    vec2 tc;
}
tes_in[];

out TES_OUT
{
    vec2 tc;
    float h;
    float x, y;
    vec4 ccolor;
}
tes_out;

//in int gl_PrimitiveID;

uniform sampler2D tex[32];

uniform mat4 matrix;
uniform float waterTime;

void main(void)
{
    vec2 tc = vec2(0.0, 0.0);
    tc += gl_TessCoord[0] * tes_in[0].tc;
    tc += gl_TessCoord[1] * tes_in[1].tc;
    tc += gl_TessCoord[2] * tes_in[2].tc;

    vec4 pos = (gl_TessCoord.x * gl_in[0].gl_Position + gl_TessCoord.y * gl_in[1].gl_Position +
                gl_TessCoord.z * gl_in[2].gl_Position);

    // float z =  ( texture(height, tc).r);
    float z = (texture(tex[3], tc).r) * 4.0;
    vec4 zz;

    //zz.z += z * 30.0 + 10.0 * sin(waterTime);
    zz.z = 36.0;
    float d = sin((pos.x + pos.y) / 64.0 + waterTime);
    d = sin((pos.x + pos.y) / 64.0 + waterTime);
    //zz.z += 0.5 * d;
    
    
        float waveLen = 15.0f;
        float pi = 3.1456f;
        float radX = (pos.x / waveLen + waterTime / 2) * .5 * pi;
        float radY = (pos.y / waveLen + waterTime / 2) * .5 * pi;
        float wa = 1.0f;
        float ww = wa * 0.5 * (sin(radX) + cos(radY));
        zz.z += ww;
        if (zz.z > 36.0)
            zz.z = 36.0;
    /*
    if (z != 0.0) {
        zz = vec4(0.0, 0.0, z * 30.0, 0.0);
    }
    else {
        zz = vec4(0.0, 0.0, sin(waterTime) * 1, 0.0);
        float waveLen = 5.0f;
        float pi = 3.1456f;
        float radX = (pos.x / waveLen + waterTime / 2) * 2.0 * pi;
        float radY = (pos.y / waveLen + waterTime / 2) * 2.0 * pi;
        float wa = 2.0f;
        float ww = wa * 0.5 * (sin(radX) + cos(radY));
        zz.z = ww;
    }
    */
    pos += zz;

    tes_out.tc = tc + sin(waterTime) * 0.0001;
    tes_out.h = z;

    tes_out.x = pos.x;
    tes_out.y = pos.y;

    gl_Position = matrix * pos;

}
