#version 450 core

layout(triangles, equal_spacing, cw) in;

in TCS_OUT
{
    vec2 tc;
}
tes_in[];

out TES_OUT
{
    vec2 tc;
    float h;
    float x, y;
    vec4 ccolor;
}
tes_out;

// in int gl_PrimitiveID;

uniform sampler2D tex[32];

uniform mat4 matrix;
uniform float waterTime;

void main(void)
{
    vec2 tc = vec2(0.0, 0.0);
    tc += gl_TessCoord[0] * tes_in[0].tc;
    tc += gl_TessCoord[1] * tes_in[1].tc;
    tc += gl_TessCoord[2] * tes_in[2].tc;

    vec4 pos = (gl_TessCoord.x * gl_in[0].gl_Position + gl_TessCoord.y * gl_in[1].gl_Position +
                gl_TessCoord.z * gl_in[2].gl_Position);

    //float z = (texture(tex[3], tc).r) * 4.0;
    vec4 zz;

    zz.z = 36.0 * 2.0 - 7.0f;
    float d = sin((pos.x + pos.y) / 64.0 + waterTime);
    d = sin((pos.x + pos.y) / 64.0 + waterTime);
    // zz.z += 0.5 * d;

    float waveLen = 15.0f;
    float pi = 3.1456f;
    float radX = (pos.x / waveLen + waterTime / 2) * .5 * pi;
    float radY = (pos.y / waveLen + waterTime / 2) * .5 * pi;
    float wa = 1.0f;
    float ww = wa * 0.5 * (sin(radX) + cos(radY));
    //zz.z += ww;
    if (zz.z > 36.0 * 2.0)
        zz.z = 36.0 * 2.0;
    pos += zz;

    tes_out.tc = tc + sin(waterTime) * 0.0001;
    tes_out.h = pos.z;

    tes_out.x = pos.x;
    tes_out.y = pos.y;

    gl_Position = matrix * pos;
}
