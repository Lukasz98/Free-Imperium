#version 450 core

layout (triangles, equal_spacing, cw) in;
// equal_spacing, cw) in;

in TCS_OUT
{
    vec2 tc;
} tes_in[];

out TES_OUT
{
    vec2 tc;
    //vec2 grass_tc;
    float h;
    float x, y;
} tes_out;

layout (binding=2) uniform sampler2D height;

uniform mat4 matrix;

void main(void)
{
    //vec2 tc1 = mix(tes_in[0].tc, tes_in[1].tc, tes_in[2].tc);
    //vec2 tc1 = mix(tes_in[0].tc, tes_in[1].tc, gl_TessCoord.x);
    //vec2 tc2 = mix(tes_in[2].tc, tes_in[3].tc, gl_TessCoord.x);
    //vec2 tc = mix(tc2, tc1, gl_TessCoord.y);
//vec2 tc = mix(tc1, gl_TessCoord.y);
vec2 tc = vec2(0.0,0.0);
tc += gl_TessCoord[0] * tes_in[0].tc;
tc += gl_TessCoord[1] * tes_in[1].tc;
tc += gl_TessCoord[2] * tes_in[2].tc;
    //float z =  (1.0 - texture(height, tc).r) * 0.0;
    float z =  ( texture(height, tc).r);
//vec4 zz = {0.0,0.0,0.0,z};
vec4 zz = {0.0, 0.0, z * 20.0, 0.0};
//gl_Position = (
vec4 pos = (
        gl_TessCoord.x * gl_in[0].gl_Position + 
        gl_TessCoord.y * gl_in[1].gl_Position + 
        gl_TessCoord.z * gl_in[2].gl_Position
        + zz 
);
tes_out.tc = tc;
tes_out.h = z;

tes_out.x = pos.x;
tes_out.y = pos.y;


gl_Position = matrix * pos;



/*

int ile_podzielen = int(1920.0 / 64.0);
int za_ktorym = int(tc.x * float(ile_podzielen));

float dl_podz = 1.0 / float(ile_podzielen);
float za_ktorym_x = dl_podz * float(za_ktorym);
float diff = tc.x - za_ktorym_x;
diff = diff * ile_podzielen;
//if (diff >= 0.99)
//diff = 0.0;
//if (diff > 1.0) diff = 1.0;

    vec2 gtc = vec2(
      diff,diff// 0.7// fs_in.tc.y * 1088 /64
    );


ile_podzielen = int(1088.0 / 64.0);
za_ktorym = int(tc.y * float(ile_podzielen));
dl_podz = 1.0 / float(ile_podzielen);
float za_ktorym_y = dl_podz * float(za_ktorym);
diff = tc.y - za_ktorym_y;
diff = diff * ile_podzielen;

//if (diff <= 0.3)
//diff = 1.0;

gtc.y = diff;



tes_out.grass_tc = gtc;
*/








}